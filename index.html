<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>家系図ジェネレーター(顔プレビュー付き)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1a1a2e;
            --container-bg: #2c2c3e;
            --card-bg: #3a3a50;
            --primary-accent: #7f5af0;
            --champion-accent: #ffc639;
            --text-color: #e0e0e0;
            --text-muted: #9a9a9a;
            --line-color: #3ce4c8;
            --line-offset-y: 90px;
        }

        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 25px;
            min-height: 100vh;
            box-sizing: border-box;
        }

        .container {
            width: 100%;
            max-width: 95%;
            background: var(--container-bg);
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 { 
            text-align: center; 
            color: #fff; 
            margin-bottom: 25px; 
            font-weight: 700;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.7);
        }

        textarea {
            width: 100%; min-height: 120px; padding: 15px; border: 2px solid #5a4a9c;
            border-radius: 8px; font-size: 16px; margin-bottom: 20px; background-color: var(--card-bg);
            color: var(--text-color); resize: none; box-sizing: border-box;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }

        textarea:focus { 
            outline: none; 
            border-color: var(--primary-accent);
            box-shadow: 0 0 10px rgba(127, 90, 240, 0.5);
        }

        .button-group { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }

        button {
            padding: 15px; border-radius: 8px; font-weight: 700; cursor: pointer;
            border: none; color: #fff; font-size: 16px;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        button:hover { transform: translateY(-2px); }

        #generate-btn { 
            background: linear-gradient(90deg, #7f5af0, #a85af0); 
            box-shadow: 0 4px 15px rgba(127, 90, 240, 0.3);
        }
        #generate-btn:hover {
            box-shadow: 0 6px 20px rgba(127, 90, 240, 0.5);
        }

        #save-btn { background: linear-gradient(90deg, #3ca1c3, #3ce4c8); box-shadow: 0 4px 15px rgba(60, 228, 200, 0.2); }
        #clear-btn { background: linear-gradient(90deg, #4b4b63, #626288); box-shadow: 0 4px 15px rgba(98, 98, 136, 0.2); }

        .bracket-container {
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
            margin-top: 40px; overflow-x: auto; padding: 20px; position: relative; background-color: var(--container-bg);
        }

        .round {
            display: flex; flex-direction: row; justify-content: center; align-items: flex-start;
            margin-top: var(--line-offset-y); width: 100%;
        }
        .round:first-child { margin-top: 0; }

        .player-card {
            border: 2px solid var(--primary-accent); background-color: var(--card-bg); padding: 12px;
            margin: 0 40px; border-radius: 8px; text-align: center; width: 220px;
            color: var(--text-color); word-wrap: break-word; box-sizing: border-box; flex-shrink: 0;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 0 0 8px rgba(127, 90, 240, 0.3);
        }
        .player-card:hover { 
            transform: translateY(-5px); 
            box-shadow: 0 8px 25px rgba(127, 90, 240, 0.5);
        }

        .round.is-crowded { justify-content: space-around; }
        .round.is-crowded .player-card {
            width: auto; flex-shrink: 1; flex-grow: 1; flex-basis: 0; min-width: 100px;
            max-width: 180px; margin: 0 5px; padding: 8px; font-size: 0.9em;
        }
        
        .player-card .name { font-weight: bold; font-size: 1.1em; margin-bottom: 8px; }

        .champion-card {
            border-color: var(--champion-accent);
            box-shadow: 0 0 15px rgba(255, 198, 57, 0.4);
        }
        .champion-card:hover {
            box-shadow: 0 8px 30px rgba(255, 198, 57, 0.6);
        }
        .champion-card .status {
            margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--text-muted); font-size: 15px;
            text-align: left; white-space: pre-wrap; color: var(--text-color);
        }
        
        #bracket-lines { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #bracket-lines path { 
            stroke: var(--line-color); 
            stroke-width: 2.5; 
            fill: none;
            filter: drop-shadow(0 0 3px var(--line-color));
        }
        
        @keyframes card-fade-in {
            from { opacity: 0; transform: translateY(15px) scale(0.98); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        .player-card.animated {
            opacity: 0;
            animation: card-fade-in 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        @keyframes draw-line { to { stroke-dashoffset: 0; } }
        #bracket-lines path.animated { animation: draw-line 1s cubic-bezier(0.47, 0, 0.745, 0.715) forwards; }
        
        .screenshot-mode h1,
        .screenshot-mode textarea:focus,
        .screenshot-mode #generate-btn,
        .screenshot-mode .player-card {
            text-shadow: none !important;
            box-shadow: none !important;
        }
        .screenshot-mode #bracket-lines path {
            filter: none !important;
            stroke-dashoffset: 0 !important;
        }
        .screenshot-mode .animated {
            animation: none !important;
            opacity: 1 !important;
            transform: none !important;
        }
        .face-preview-container { width: 200px; height: 200px; position: relative; background-color: transparent; margin: 0 auto 10px auto; border-radius: 16px; overflow: hidden; }
        .face-preview-container .part-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-size: contain; background-repeat: no-repeat; background-position: center; }
        .preview-kami-rinkaku { z-index: 2; transform: scale(1) translate(0px, 0px) rotate(0deg); }
        .preview-hoo { z-index: 3; transform: scale(0.7) translate(5px, 45px) rotate(0deg); }
        .preview-me { z-index: 4; transform: scale(0.65) translate(3px, 0px) rotate(0deg); }
        .preview-mayu { z-index: 5; transform: scale(0.55) translate(0px, -57px) rotate(0deg); }
        .preview-hana { z-index: 6; transform: scale(0.3) translate(-10px, 60px) rotate(0deg); }
        .preview-kuchi { z-index: 7; transform: scale(0.6) translate(5px, 75px) rotate(0deg); }
        .color-info-container { display: flex; flex-direction: column; align-items: center; gap: 5px; margin-bottom: 12px; }
        .color-info-item { display: flex; align-items: center; justify-content: center; font-size: 1em; color: var(--text-color); }
        .color-preview-box { width: 22px; height: 22px; border: 1px solid var(--text-muted); border-radius: 4px; margin-left: 8px; background-size: cover; background-position: center; }
        .custom-color-palette { display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 8px; margin-bottom: 15px; padding-top: 5px; }
        .palette-item { display: flex; align-items: center; font-size: 0.9em; }
        .palette-color-box { width: 18px; height: 18px; border: 1px solid var(--text-muted); border-radius: 3px; margin-right: 5px; }
        .pattern-rank { background-color: var(--bg-color); padding: 2px 8px; border-radius: 4px; border: 1px solid var(--primary-accent); font-weight: bold; color: var(--text-color); }
        .qr-code { width: 160px; height: 160px; margin: 10px auto 0; background-color: #ffffff; border-radius: 4px; padding: 5px; display: flex; align-items: center; justify-content: center; box-sizing: border-box; cursor: pointer; }
        .round.is-crowded .qr-code { width: 100%; height: auto; aspect-ratio: 1 / 1; max-width: 120px; }
        .round.is-crowded .qr-code > * { width: 100% !important; height: 100% !important; }
        .rsid-text { color: #ccc; font-size: 14px; font-family: monospace; margin-top: 8px; word-break: break-all; }
        #error-message { color: #f96666; text-align: center; margin-top: 15px; display: none; font-weight: 700; }
        .modal-overlay { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); justify-content: center; align-items: center; animation: modalFadeIn 0.3s ease; }
        @keyframes modalFadeIn { from { opacity: 0; } to { opacity: 1; } }
        #modal-content { position: relative; }
        #close-modal { position: absolute; top: -15px; right: -15px; color: #fff; font-size: 40px; font-weight: bold; cursor: pointer; transition: color 0.2s; }
        #close-modal:hover { color: #bbb; }
    </style>
</head>
<body>

<div class="container">
    <h1>家系図ジェネレーター(顔プレビュー付き)</h1>
    <textarea id="rsid-input" placeholder="RSIDを貼り付けてください"></textarea>
    <div class="button-group">
        <button id="generate-btn">家系図を生成</button>
        <button id="save-btn">画像として保存</button>
        <button id="clear-btn">削除</button>
    </div>
    <p id="error-message"></p>
    <div class="bracket-container" id="bracket-container">
        <svg id="bracket-lines"></svg>
    </div>
</div>

<div id="modal-overlay" class="modal-overlay">
    <span id="close-modal">&times;</span>
    <div id="modal-content"></div>
</div>

<script>
    let currentRoundsData = [];

    function parseNode(str) { str = str.trim(); if (!str.startsWith("(")) { const parts = str.split(/\s+/); const id = parts.shift(); const name = parts.join(" "); return { id, name, participants: [] }; } let balance = 0, end = -1; for (let i = 0; i < str.length; i++) { if (str[i] === "(") balance++; else if (str[i] === ")") balance--; if (balance === 0) { end = i; break; } } if (end === -1) throw new Error("括弧の対応が正しくありません。"); const winner = str.substring(end + 1).trim(); const inside = str.substring(1, end).trim(); let depth = 0, split = -1; for (let i = 0; i < inside.length; i++) { if (inside[i] === "(") depth++; else if (inside[i] === ")") depth--; else if (inside[i] === "+" && depth === 0) { split = i; break; } } if (split === -1) throw new Error("'+' 区切りが見つかりません。"); const left = inside.substring(0, split).trim(); const right = inside.substring(split + 1).trim(); return { name: winner, participants: [parseNode(left), parseNode(right)], id: null }; }

    function drawLines(rounds) { if (!rounds || rounds.length === 0) return; const container = document.getElementById('bracket-container'); const svg = document.getElementById('bracket-lines'); svg.innerHTML = ''; svg.setAttribute('width', container.scrollWidth); svg.setAttribute('height', container.scrollHeight); const style = getComputedStyle(document.documentElement); const lineOffsetY = parseFloat(style.getPropertyValue('--line-offset-y')); function getElementPosition(id) { const el = document.getElementById(id); if (!el) return null; const containerRect = container.getBoundingClientRect(); const elRect = el.getBoundingClientRect(); return { cx: elRect.left - containerRect.left + container.scrollLeft + elRect.width / 2, top: elRect.top - containerRect.top + container.scrollTop, bottom: elRect.top - containerRect.top + container.scrollTop + elRect.height, }; } function connectCards(fromIds, toId, delay) { const toPos = getElementPosition(toId); if (!toPos) return; const fromPositions = fromIds.map(getElementPosition).filter(Boolean); if (fromPositions.length === 0) return; const path = document.createElementNS("http://www.w3.org/2000/svg", "path"); let pathData = ""; const maxBottom = Math.max(...fromPositions.map(pos => pos.bottom)); const verticalLineY = maxBottom + lineOffsetY / 2; fromPositions.forEach(fromPos => { pathData += `M ${fromPos.cx},${fromPos.bottom} L ${fromPos.cx},${verticalLineY} `; }); if (fromPositions.length > 1) { const firstX = fromPositions[0].cx; const lastX = fromPositions[fromPositions.length - 1].cx; pathData += `M ${firstX},${verticalLineY} L ${lastX},${verticalLineY} `; } const midX = fromPositions.reduce((sum, p) => sum + p.cx, 0) / fromPositions.length; pathData += `M ${midX},${verticalLineY} L ${toPos.cx},${verticalLineY} L ${toPos.cx},${toPos.top} `; path.setAttribute("d", pathData); const length = path.getTotalLength(); path.style.strokeDasharray = length; path.style.strokeDashoffset = length; path.style.animationDelay = `${delay}s`; path.classList.add('animated'); svg.appendChild(path); } for (let i = 0; i < rounds.length - 1; i++) { const parentRound = rounds[i+1]; parentRound.forEach(parentNode => { if(parentNode.participants && parentNode.participants.length > 0) { const childIds = parentNode.participants.map(p => p.uniqueId); const lineAnimationDelay = 0.3 + (i * 0.2); connectCards(childIds, parentNode.uniqueId, lineAnimationDelay); } }); } }

    function applyFaceParts(championCardId, statusText) { const championEl = document.getElementById(championCardId); if (!championEl) return; const partAndColorConfig = { "髪色": { selector: '.hair-color-box', folder: '髪色画像' }, "肌色": { selector: '.skin-color-box', folder: '肌色画像' }, "髪": { selector: '.preview-kami-rinkaku', folder: '髪・輪郭画像' }, "眉": { selector: '.preview-mayu', folder: '眉画像' }, "目": { selector: '.preview-me', folder: '目画像' }, "鼻": { selector: '.preview-hana', folder: '鼻画像' }, "頬": { selector: '.preview-hoo', folder: '頬画像' }, "口": { selector: '.preview-kuchi', folder: '口画像' } }; for (const config of Object.values(partAndColorConfig)) { const element = championEl.querySelector(config.selector); if (element) { element.style.backgroundImage = 'none'; } } if (statusText) { for (const [key, config] of Object.entries(partAndColorConfig)) { const regex = new RegExp(`${key}:(\\d+)`); const match = statusText.match(regex); if (match && match[1]) { const partNumber = match[1]; const element = championEl.querySelector(config.selector); if (element) { element.style.backgroundImage = `url('${config.folder}/${partNumber}.png')`; } } } } }
    
    const COLOR_MAP = { "黒": "#2c2c2c", "濃黒": "#000000", "薄黒": "#696969", "赤": "#e60012", "濃赤": "#a2000b", "薄赤": "#f19ca3", "水色": "#00a0e9", "濃水色": "#0072a6", "薄水色": "#89c3eb", "緑": "#009944", "濃緑": "#00672e", "薄緑": "#8ac59f", "橙": "#f39800", "濃橙": "#ab6a00", "薄橙": "#f9c988", "黄色": "#fff100", "濃黄色": "#b2a900", "薄黄色": "#fff888", "青": "#0068b7", "濃青": "#00477f", "薄青": "#89b2d3", "白": "#ffffff", "濃白": "#f0f0f0", "薄白": "#ffffff", "紫": "#8f4e9d", "濃紫": "#64366d", "薄紫": "#c3a5cb", "桃": "#e4007f", "濃桃": "#a00059", "薄桃": "#ef89ba", "金": "#b59e38", "濃金": "#7e6e27", "薄金": "#d3c285", "銀": "#8a8c8e", "濃銀": "#606263", "薄銀": "#c2c3c4", "通常黒": "#2c2c2c", "通常赤": "#e60012", "通常水色": "#00a0e9", "通常緑": "#009944", "通常橙": "#f39800", "通常黄色": "#fff100", "通常青": "#0068b7", "通常白": "#ffffff", "通常紫": "#8f4e9d", "通常桃": "#e4007f", "通常金": "#b59e38", "通常銀": "#8a8c8e" };
    const PATTERN_RANK_MAP = { 'なし': 'D(単色)', 'ツートン': 'C', 'ボーダー': 'C', 'ストライプ': 'C', '水玉': 'C', 'アニマル': 'C', '斜めボーダー': 'C', 'ギンガムチェック': 'B', 'ダイヤ': 'B', '鱗文': 'B', 'シェブロン': 'B', 'バブルドット': 'B', 'スペード': 'B', 'ピンドット': 'A', 'レンガ': 'A', 'スプラッシュ': 'A', 'マーブル': 'A', 'ヘビ': 'A', 'しずく': 'A', 'うろこ': 'A', 'トラ': 'S', '花': 'S', '星': 'S' };
    function applyAppearanceInfo(championCardId, statusText) { const championEl = document.getElementById(championCardId); const paletteContainer = championEl.querySelector('.custom-color-palette'); if (!paletteContainer) return; paletteContainer.innerHTML = ''; if (!statusText) return; const colorMatch = statusText.match(/色:([\s\S]*?)(柄:|髪:|眉:|目:|鼻:|頬:|口:|$)/); if (colorMatch && colorMatch[1]) { const colorNames = colorMatch[1].trim().split(/\s+/); colorNames.forEach(name => { if (COLOR_MAP[name]) { const item = document.createElement('div'); item.className = 'palette-item'; const box = document.createElement('div'); box.className = 'palette-color-box'; box.style.backgroundColor = COLOR_MAP[name]; const text = document.createTextNode(name); item.appendChild(box); item.appendChild(text); paletteContainer.appendChild(item); } }); } const patternMatch = statusText.match(/柄:([\s\S]*?)(髪:|髪色:|肌色:|眉:|目:|鼻:|頬:|口:|$)/); if (patternMatch && patternMatch[1]) { const patternName = patternMatch[1].trim(); const rank = PATTERN_RANK_MAP[patternName]; if (rank) { const item = document.createElement('div'); item.className = 'palette-item pattern-rank'; item.textContent = `柄ランク:${rank}`; let borderColor = 'var(--primary-accent)'; if (rank === 'D(単色)') { borderColor = '#FFFFFF'; } else if (rank === 'C') { borderColor = '#90EE90'; } else if (rank === 'B') { borderColor = '#ADD8E6'; } else if (rank === 'A') { borderColor = '#F08080'; } item.style.borderColor = borderColor; paletteContainer.appendChild(item); } } }

    function setupQRCodeModal() { const modalOverlay = document.getElementById('modal-overlay'); const modalContent = document.getElementById('modal-content'); const closeModalBtn = document.getElementById('close-modal'); const closeModal = () => { modalOverlay.style.display = 'none'; modalContent.innerHTML = ''; }; document.querySelectorAll('.qr-code').forEach(qrEl => { qrEl.addEventListener('click', (event) => { const qrData = event.currentTarget.dataset.id; if (qrData) { const qrContainer = document.createElement('div'); qrContainer.style.background = 'white'; qrContainer.style.padding = '15px'; qrContainer.style.borderRadius = '8px'; modalContent.appendChild(qrContainer); new QRCode(qrContainer, { text: qrData, width: 400, height: 400 }); modalOverlay.style.display = 'flex'; } }); }); closeModalBtn.addEventListener('click', closeModal); modalOverlay.addEventListener('click', (event) => { if (event.target === modalOverlay) { closeModal(); } }); }

    document.getElementById('generate-btn').addEventListener('click', () => {
        const input = document.getElementById('rsid-input').value.trim();
        const errorEl = document.getElementById('error-message');
        const container = document.getElementById('bracket-container');
        container.innerHTML = '<svg id="bracket-lines"></svg>';
        errorEl.style.display = 'none';
        currentRoundsData = [];
        if (!input) return;
        try {
            let stringToParse = input;
            let statusString = '';
            let formattedStatus = '';
            const treeForCheck = parseNode(stringToParse);
            const winnerName = treeForCheck.name;
            const headIndex = winnerName.indexOf('頭:');
            if (headIndex !== -1) {
                statusString = winnerName.substring(headIndex);
                const winnerNameOnly = winnerName.substring(0, headIndex).trim();
                const lastWinnerNameIndex = stringToParse.lastIndexOf(winnerName);
                stringToParse = stringToParse.substring(0, lastWinnerNameIndex) + winnerNameOnly;
            }
            if (statusString) {
                let tempStatus = statusString;
                tempStatus = tempStatus.replace(
                    /(色:)([\s\S]*?)(?=(?:柄:|髪:|髪色:|肌色:|眉:|目:|鼻:|頬:|口:)|$)/,
                    (match, colorKeyword, colorText) => {
                        const processedText = colorText.trim().replace(/\s+/g, '&');
                        return colorKeyword + processedText + '\n';
                    }
                );
                formattedStatus = tempStatus.replace(/\s+/g, '\n').trim();
            }
            const tree = parseNode(stringToParse);
            const roundsData = [];
            function assignDepthAndId(node, depth) { if (!roundsData[depth]) roundsData[depth] = []; node.uniqueId = `d${depth}_${roundsData[depth].length}`; roundsData[depth].push(node); node.participants.forEach(p => assignDepthAndId(p, depth + 1)); }
            assignDepthAndId(tree, 0);
            const reversedRounds = [...roundsData].reverse();
            currentRoundsData = reversedRounds;
            let html = "";
            let cardCounter = 0;
            reversedRounds.forEach((round, i) => {
                const isChampionRound = i === reversedRounds.length - 1;
                html += `<div class="round">`;
                html += round.map(node => {
                    const cardHtml = isChampionRound ?
                         `<div class="player-card champion-card" id="${node.uniqueId}" style="animation-delay: ${cardCounter * 0.07}s">
                            <div class="face-preview-container"> <div class="part-layer preview-kami-rinkaku"></div> <div class="part-layer preview-hoo"></div> <div class="part-layer preview-me"></div> <div class="part-layer preview-mayu"></div> <div class="part-layer preview-hana"></div> <div class="part-layer preview-kuchi"></div> </div>
                            <div class="color-info-container"> <div class="color-info-item">髪色<div class="color-preview-box hair-color-box"></div></div> <div class="color-info-item">肌色<div class="color-preview-box skin-color-box"></div></div> </div>
                            <div class="custom-color-palette"></div>
                            <div class="name">${node.name}</div>
                            ${formattedStatus ? `<div class="status">${formattedStatus}</div>` : ''}
                        </div>`
                        : `<div class="player-card" id="${node.uniqueId}" style="animation-delay: ${cardCounter * 0.07}s"><div class="name">${node.name}</div>${!node.participants.length ? `<div class="qr-code" data-id="${node.id}"></div><div class="rsid-text">${node.id}</div>` : ''}</div>`;
                    cardCounter++;
                    return cardHtml;
                }).join('');
                html += `</div>`;
            });
            container.insertAdjacentHTML('beforeend', html);
            document.querySelectorAll('.player-card').forEach(card => card.classList.add('animated'));
            document.querySelectorAll('.round').forEach(roundEl => { if (roundEl.querySelectorAll('.player-card').length >= 7) { roundEl.classList.add('is-crowded'); } });
            document.querySelectorAll('.qr-code').forEach(el => { if (el.dataset.id) { new QRCode(el, { text: el.dataset.id, width: 150, height: 150 }); } });
            setupQRCodeModal();
            const championNode = reversedRounds[reversedRounds.length - 1][0];
            if (championNode) {
                applyFaceParts(championNode.uniqueId, statusString);
                applyAppearanceInfo(championNode.uniqueId, statusString);
            }
            requestAnimationFrame(() => { drawLines(currentRoundsData); });
        } catch (e) { errorEl.textContent = "エラー: " + e.message; errorEl.style.display = 'block'; }
    });

    document.getElementById('clear-btn').addEventListener('click', () => { document.getElementById('rsid-input').value = ''; document.getElementById('bracket-container').innerHTML = '<svg id="bracket-lines"></svg>'; document.getElementById('error-message').style.display = 'none'; currentRoundsData = []; });
    
    document.getElementById('save-btn').addEventListener('click', () => {
        const container = document.getElementById('bracket-container');
        if (!container || container.children.length <= 1) { alert('先に家系図を生成してください。'); return; }
        container.classList.add('screenshot-mode');
        setTimeout(() => {
            html2canvas(container, {
                useCORS: true, scale: 3, backgroundColor: "#2c2c3e", imageSmoothingEnabled: false
            }).then(canvas => {
                const link = document.createElement('a');
                link.href = canvas.toDataURL('image/png');
                link.download = 'family-tree.png';
                link.click();
            }).finally(() => {
                container.classList.remove('screenshot-mode');
            });
        }, 100);
    });

    const textarea = document.getElementById('rsid-input');
    textarea.addEventListener('input', () => { textarea.style.height = 'auto'; textarea.style.height = `${textarea.scrollHeight}px`; });
    let resizeTimer;
    window.addEventListener('resize', () => { clearTimeout(resizeTimer); resizeTimer = setTimeout(() => { drawLines(currentRoundsData); }, 200); });

</script>
</body>
</html>
